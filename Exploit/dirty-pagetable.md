# 内核利用技术：页表利用与 Dirty Pagetable

本文综合了页表利用技术的理论基础与实战技巧，重点介绍 Dirty Pagetable 方法。内容整合自：
- [Kernel Exploitation Techniques: Turning The (Page) Tables](https://sam4k.com/page-table-kernel-exploitation/)
- [Dirty Pagetable 原始文章](https://yanglingxi1993.github.io/dirty_pagetable/dirty_pagetable.html)

## 目录

- [分页基础知识](#分页基础知识)
  - [页表结构与地址翻译](#页表结构与地址翻译)
  - [用户页表的分配机制](#用户页表的分配机制)
- [页表利用技术概览](#页表利用技术概览)
  - [为什么页表是强大的攻击面](#为什么页表是强大的攻击面)
  - [页级原语](#页级原语)
  - [SLAB 到页级的转换](#slab-到页级的转换)
- [Dirty Pagetable 详解](#dirty-pagetable-详解)
  - [技术简介](#技术简介)
  - [利用步骤](#利用步骤)
  - [技术挑战与解决方案](#技术挑战与解决方案)
- [PTE 结构与巨页](#pte-结构与巨页)
  - [PTE 条目详解](#pte-条目详解)
  - [巨页利用](#巨页利用)
  - [页表漫步实战](#页表漫步实战)
- [攻击路径与缓存处理](#攻击路径与缓存处理)
  - [常见攻击思路](#常见攻击思路)
  - [TLB 与缓存刷新](#tlb-与缓存刷新)
- [缓解措施](#缓解措施)
  - [物理 KASLR](#物理-kaslr)
  - [只读内存保护](#只读内存保护)
- [参考资料](#参考资料)

---

## 分页基础知识

### 页表结构与地址翻译

在深入页表利用之前，需要理解 Linux 的分页机制。简单来说：

- 程序存于磁盘 → 加载到 RAM → 物理地址映射到进程虚拟地址空间
- 访问虚拟地址时，硬件通过**页表**翻译为物理地址

虚拟内存按固定大小的**页**（PAGE_SIZE，通常 4096 字节）划分。每个进程和内核都有独立的页表，按层级组织：

**Linux 页表层级（最多 5 级）：**
- **PGD**（Page Global Directory）→ P4D
- **P4D**（Page Level 4 Directory）→ PUD  
- **PUD**（Page Upper Directory）→ PMD
- **PMD**（Page Middle Directory）→ PT
- **PT**（Page Table）：PTE 指向物理页

许多系统使用 4 级页表（折叠 P4D）。每张页表本身大小为 PAGE_SIZE。

**地址翻译机制：**

虚拟地址的不同位段用作各层页表的索引。以 x86_64 为例：
- 低 48 位用于寻址（高位做符号扩展）
- 位 47 的符号扩展决定低地址（用户态）或高地址（内核态）

**关键要点：**
- 页表条目不仅是指针，还携带权限等元数据
- PMD/PUD 通过设置 PS 位可映射巨页（PMD=2MB，PUD=1GB）
- 自 Meltdown 后引入 KPTI（Kernel Page Table Isolation），用户态页表移除了内核映射

**参考资料：**
1. https://docs.kernel.org/mm/page_tables.html  
2. https://github.com/lorenzo-stoakes/linux-vm-notes/blob/master/sections/page-tables.md

### 用户页表的分配机制

内核页表在启动时建立；用户页表采用**按需分配**（demand allocation）：访问有效虚拟地址时，缺失的中间页表会自动分配。

**页表覆盖范围计算：**

每个页表 4096 字节，64 位表项，故每表 512 项：
- **PT**（PTE 层）：512 × 4096 = 2MB
- **PMD**：512 × 2MB = 1GB  
- **PUD**：512 × 1GB = 512GB
- **PGD**：256TB

这意味着 PTE 表首条目对应的虚拟地址是 **2MB 对齐**的。

**分配代码（x86_64）：**

```c
// arch/x86/mm/pgtable.c
gfp_t __userpte_alloc_gfp = GFP_PGTABLE_USER | PGTABLE_HIGHMEM;

pgtable_t pte_alloc_one(struct mm_struct *mm)
{
    return __pte_alloc_one(mm, __userpte_alloc_gfp);
}
```

```c
// include/asm-generic/pgalloc.h
static inline struct ptdesc *pagetable_alloc_noprof(gfp_t gfp, unsigned int order)
{
    struct page *page = alloc_pages_noprof(gfp | __GFP_COMP, order);
    return page_ptdesc(page);
}
```

**关键结论：**

用户页表通过**页分配器**分配，GFP 标志为 `GFP_PGTABLE_USER | PGTABLE_HIGHMEM | __GFP_COMP`：
- **order-0 页**（单页）
- **ZONE_NORMAL / MIGRATE_UNMOVABLE**

这为后续利用提供了关键信息：我们需要控制同等条件下从页分配器分配的页。

---

## 页表利用技术概览

### 为什么页表是强大的攻击面

一旦控制一个 PTE（或能映射巨页的 PMD 条目），攻击者能够：
1. **改写虚拟映射权限**（如将只读改为可写）
2. **指向任意物理地址**（绕过虚拟 KASLR）

这意味着强大的**任意物理地址读/写**能力，可绕过：
- 虚拟 KASLR
- CFI
- SMAP/PAN  
- 堆随机化/强化

**但挑战在于：如何获得页表控制权？**

### 页级原语

最理想情况：直接拥有 **order-0 页级 UAF**，zone/migrate 类型合适。

通过堆风水（heap feng shui），让 UAF 页被重新分配为用户页表页。即使初始不是 order-0，也可耗尽低阶页迫使 buddy 系统拆分高阶页。

**公开案例（多来自 GPU 漏洞）：**
- GPUAF – Two ways of Rooting All Qualcomm based Android phones（aarch64）
- The Way to Android Root: Exploiting Your GPU On Smartphone（aarch64）

### SLAB 到页级的转换

若只有 **SLAB 级 UAF** 怎么办？

SLAB 底层也由页分配器分配。可诱导包含 UAF 对象的 SLAB 被释放回页分配器，再让该页重新分配为用户页表。

这正是 **Dirty Pagetable**（2023）和 **PageJack**（2024）的核心思想。

**相关研究：**
- Understanding Dirty Pagetable（x86_64，2023）
- Flipping Pages（x86_64，2024）：详细讨论物理 KASLR 绕过与缓存刷新

---

## Dirty Pagetable 详解

### 技术简介

**Dirty Pagetable** 是一种全新的内核漏洞利用方法，核心思想：利用基于堆的漏洞操纵用户页表，获得**读写任意物理地址**的能力。

**显著优势：**

1. **纯数据（data-only）利用技术**  
   天然绕过 CFI、KASLR、SMAP/PAN 等缓解，易于开发通用利用

2. **适用于最新内核**  
   内核空间镜像攻击（KSMA）在新版内核已被缓解，但 Dirty Pagetable 依然有效

3. **提升堆漏洞利用效果**  
   许多漏洞倾向攻击只读文件的页缓存，在 Android 上需额外努力。Dirty Pagetable 可直接攻击内核，简化提权流程

**实战成果：**

在 Google Pixel 7（迄今最安全、最注重隐私的手机）上，利用 0-day 漏洞（CVE-2023-21400）成功提权，绕过所有缓解技术。还为文件 UAF 和 pid UAF 开发了新的利用方法。

### 利用步骤

以常见的 UAF 漏洞为例，分步骤说明如何借助 Dirty Pagetable 完成利用：

#### 步骤 1：触发 UAF，使"受害 slab"被回收回页分配器

UAF 漏洞导致堆对象被提前释放，但之后仍可能被使用。我们称之为"受害对象（victim object）"，其所在 slab 为"受害 slab（victim slab）"。

**操作流程：**
1. 触发 UAF，释放受害对象
2. 继续释放受害 slab 中的其他所有对象
3. 该 slab 成为空 slab，被回收回页分配器

> 许多研究已讨论如何快速、稳定地让空 slab 被页分配器回收，此处不赘述。

##### 步骤 2：用用户页表占用受害 slab

由于用户页表直接从页分配器分配，可通过大量分配用户页表来占用受害 slab。**注意：使用末级页表（last-level page tables）。**

成功占用后的场景：

![](./images/pic1_occupy_with_pagetable.svg)

如图所示，受害对象此时位于用户页表之中。

#### 步骤 3：构造可任意改写页表项（PTE）的利用原语

完成步骤 2 后显而易见：只要用受害对象构造出写原语，就能按需修改 PTE。

**挑战：如何利用受害对象构造合适的原语以修改 PTE。**

> TODO: 添加三个具体例子。

假定已拿到能任意改写用户页表内 PTE 的写原语。

#### 步骤 4：通过修改 PTE 给内核打补丁

控制某一 PTE 后，将其物理地址指向内核代码段或数据段，即可随意"打补丁"。

**提权路径：**

给系统调用打补丁（如 `setresuid()`、`setresgid()`），使普通进程也能调用。若启用 SELinux，还需修改相关变量将其关闭。

#### 步骤 5：获取 root 权限

系统调用已被补丁修改，直接执行：

```c
if (setresuid(0, 0, 0) < 0) {
    perror("setresuid");
} else {
    if (setresgid(0, 0, 0) < 0) {
        perror("setresgid");
    } else {
        printf("[+] Spawn a root shell\n");
        system("/system/bin/sh");
    }
}
```

以上五步展示了 Dirty Pagetable 的最简流程。

### 技术挑战与解决方案

在实际利用过程中，遇到了一些需要克服的障碍：

#### 挑战 1：如何刷新 TLB 与页表缓存

### 步骤 3：构造可任意改写页表项（PTE）的利用原语  

完成步骤 2 后显而易见：只要我们能用受害对象构造出一种写（write）原语，就能按需修改页表项（PTE）。

在 Dirty Pagetable 中，如何利用受害对象构造出合适的原语以修改 PTE 是一大挑战。

> TODO: 添加三个例子。

至此，可假定我们已经拿到了一个能任意改写用户页表内 PTE 的写原语。

### 步骤 4：通过修改 PTE 打补丁到内核  

完成步骤 3 后，我们便能够控制某一 PTE。只需将该 PTE 的物理地址指向内核代码段或数据段的物理地址，就可以随意给内核“打补丁”！

为了完成权限提升，我们选择给若干系统调用打补丁，如 setresuid()、setresgid() 等，使得普通进程也能直接调用它们。如果系统启用了 SELinux，还可能需要再修改 SELinux 相关变量以将其关闭。

### 步骤 5：获取 root 权限  

由于 setresuid() 和 setresgid() 已被补丁修改，我们只需执行以下代码即可直接获得 root 权限：

```c
if (setresuid(0, 0, 0) < 0) {
    perror("setresuid");
} else {
    if (setresgid(0, 0, 0) < 0) {
        perror("setresgid");
    } else {
        printf("[+] Spawn a root shell\n");
        system("/system/bin/sh");
    }
}
```

以上五个步骤展示了 Dirty Pagetable 的最简流程。

## 挑战

在利用相关漏洞的过程中，我们碰到了一些难以直接解决的问题，它们一度阻碍了 Dirty Pagetable 的正常使用。我们花了大量时间才将这些障碍逐一排除。下面列出这些难题及我们的解决方案。

#### 挑战 1：如何刷新 TLB 与页表缓存

为加速 MMU 页表查找，ARM64 引入了多级缓存（如 TLB 和专用页表缓存）。要在 Dirty Pagetable 中成功利用，必须在访问用户页表前可靠刷新这些缓存，否则内核补丁可能无法生效。

**解决方案：**

采用 Stephan van Schaik 等人在论文《Reverse Engineering Hardware Page Table Caches Using Side-Channel Attacks on the MMU》中提出的方法，能够稳定刷新 TLB 及其余页表缓存。

#### 挑战 2：如何避免对页表的意外操作

**两类意外行为：**

1. **误用非末级页表占用受害 slab**  
   例如用 2 级页表占位而非所需的 3 级（末级）页表。只有末级页表占位正确，Dirty Pagetable 才能按预期工作。
   
   **规避方法：** 在用末级页表做堆喷前，先触发一次非末级页表分配，将其"预占"，确保后续只分配末级页表到受害 slab。

2. **内核可能将正要修改的 PTE 所指页面换出（swap out）**  
   此时 PTE 变为非法，访问对应虚拟地址会导致内核 panic。
   
   **规避方法：**
   - 使用 `mlock()` 锁定该虚拟地址对应页面
   - 避免系统内存压力过大，防止页被换出

---

## PTE 结构与巨页

### PTE 条目详解

PTE 是 8 字节，结构如下：

**x86_64 PT Entry：**

![x86_64 PTE](https://sam4k.com/content/images/2025/05/x86_64_pte-1.png)

- **地址位**：决定虚拟页映射到哪个物理页
- **权限位**：控制访问权限（如将只读改为可写）
- **低 12 位**：因页对齐必为 0，用作元数据位
- **高位**（超过最大物理位 M）：也用作元数据

**对我们最有用的：**
- 修改地址位 → 任意物理地址 R/W
- 修改权限位 → 将只读文件（SUID 二进制/系统库）改为可写

### 巨页利用

PMD、PUD 也由页分配器分配，可成为攻击目标。默认它们指向下一层表，但设置 **PS 位**可直接映射巨页：
- **PMD + PS=1**：映射 2MB 巨页
- **PUD + PS=1**：映射 1GB 巨页

**x86_64 PUD/PMD/PT Entry：**

![x86_64 PUD/PMD Entry](https://sam4k.com/content/images/2025/05/x86_64_pmd_pud.png)

由于对齐更粗，地址位更少，但可用于快速探测/扫描物理内存。

### 页表漫步实战

为验证前面知识，下面展示一个实战案例：用小程序在固定地址建立三段映射，并通过 QEMU+GDB 逐级走表验证。

**示例程序：**

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

#define PAGE_SIZE (0x1000UL)
#define PT_SIZE (512 * PAGE_SIZE) // 0x200000
#define PMD_SIZE (512 * PT_SIZE)  // 0x40000000
#define PUD_SIZE (512 * PMD_SIZE) // 0x8000000000
#define PGD_SIZE (512 * PUD_SIZE) // 0x1000000000000

int main()
{
    int fd = open("test.txt", O_RDONLY);

    mmap((void*)PUD_SIZE + PMD_SIZE + PT_SIZE, 0x1000, PROT_READ | PROT_WRITE, 
         MAP_ANONYMOUS | MAP_PRIVATE | MAP_FIXED | MAP_POPULATE, -1, 0);
    mmap((void*)PUD_SIZE + PMD_SIZE + PT_SIZE + PAGE_SIZE, 0x1000, PROT_READ, 
         MAP_ANONYMOUS | MAP_PRIVATE | MAP_FIXED | MAP_POPULATE, -1, 0);
    mmap((void*)PUD_SIZE + PMD_SIZE + PT_SIZE + PAGE_SIZE + PAGE_SIZE, 0x1000, PROT_READ, 
         MAP_PRIVATE | MAP_FIXED | MAP_POPULATE, fd, 0);

    getchar(); // 暂停，便于在下一次 mmap() 前下断点
    mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);

    return 0;
}
```

**调试步骤：**

1. 运行程序，在 `getchar()` 处暂停
2. GDB 中在 `vm_area_alloc(mm)` 设断点
3. 继续程序，获取 `mm_struct` 引用（包含 PGD 指针）
4. 逐级走表：PGD → PUD → PMD → PT

通过计算地址位段定位各层索引，经内核物理内存直接映射（physmap，x86_64 为 `0xffff888000000000`）转换物理地址，逐级打印校验。

**结果：** 能看到三条连续 PTE，权限与映射均符合预期。

---

## 攻击路径与缓存处理

### 常见攻击思路

根据不同原语，可考虑：

**1. 覆盖地址位**
- 获得任意物理地址 R/W
- 对 PUD/PMD 设置 PS 位映射巨页

**2. 覆盖权限位**
- 使进程映射的只读文件（库/二进制）变可写

**拥有 AAW（任意写）后的路径：**

- **禁用 SELinux**：覆盖 `selinux_state` 等
- **补丁内核**：修改 `setresuid()`/`setresgid()` 以提权
- **覆盖 `modprobe_path`**（在仍可用的系统上）
- **操纵任务链表**：从 `init_task` 找到本进程 `cred` 提权，或伪造 `init` 凭据
- **修改共享库**：注入载荷到特权进程使用的库
- **修改 SUID 二进制**：拿交互式 root shell

### TLB 与缓存刷新

页表翻译由 MMU 硬件完成，出于性能考虑引入多级缓存（TLB 为主要缓存）。

**为何需要刷新：**

当我们直接修改 PTE 或相关页时，需刷新相应缓存，确保硬件感知最新更改。否则：
- 内核补丁可能无法生效
- 访问可能仍使用旧的地址翻译

**平台差异：**

- **aarch64**：Dirty Pagetable 文章详细讨论了 ARM64 的 TLB/页表缓存刷新
- **x86_64**：Flipping Pages 文章提供了详细的刷新技巧

---

## 缓解措施

页表利用虽能绕开许多"虚拟地址层"缓解（虚拟 KASLR、CFI、堆随机化等），但仍需面对以下防御：

### 物理 KASLR

KASLR 通常指"内核虚拟地址"随机化；页表利用涉及"物理地址"，需关注"物理 KASLR"。

**平台差异：**

- **x86_64**：`CONFIG_RANDOMIZE_BASE` 同时随机化物理和虚拟地址（独立）
  - 物理起始地址受 `CONFIG_PHYSICAL_START` 对齐（默认 0x1000000）
  - 受 `CONFIG_PHYSICAL_ALIGN` 影响（常见 0x200000，x86_64 最小值）

- **aarch64（上游）**：通常只有虚拟地址随机化，无统一物理 KASLR
  - 部分厂商（如三星）在移动平台引入自家物理 KASLR

**绕过策略：**

若缺少信息泄露，可结合对齐约束进行物理扫描/暴力穷举：
1. 用 PTE 改写大量候选物理基址探测
2. 用巨页映射物理大块，做模式匹配/签名搜索

**Dirty Pagetable 的应对：**

虽无法直接获知内核精确物理地址，但可转而篡改其他无需绕过地址随机化的内核堆数据完成提权。因此，KASLR 仅提供**有限缓解**。

### 只读内存保护

**问题：** 既然直接读写物理内存，谁能阻止？

**答案：** 更高特权层。

**三星 RKP（Real-time Kernel Protection）示例：**

运行在更高特权级的 hypervisor，使用**两级地址转换**控制内核可见的物理内存：
- 可将关键区域标记为只读
- 即使在内核态做物理写也会被拦截
- 保护关键数据结构（如 `cred_jar`、全局变量、内核页表等）

**Dirty Pagetable 的应对：**

RKP 一般不直接保护"用户页表"，但会约束拿到"物理 R/W"后的可行路径。

**更强缓解措施：**

1. **将用户页表设为只读**  
   显著削弱 Dirty Pagetable，但会增加内核修改页表的额外开销

2. **借助 Hypervisor 或 TrustZone**  
   把内核代码段及其他关键内存区域设为只读，是目前**最有效的防御手段**之一，可彻底阻止篡改内核代码及关键数据

---

## 参考资料

### 核心技术文章

1. **Dirty Pagetable**（@NVamous，2023，aarch64）  
   https://web.archive.org/web/20250304082609/https://yanglingxi1993.github.io/dirty_pagetable/dirty_pagetable.html

2. **Understanding Dirty Pagetable**（x86_64，2023）  
   https://ptr-yudai.hatenablog.com/entry/2023/12/08/093606

3. **Flipping Pages**（x86_64，2024）  
   https://pwning.tech/nftables/  
   详细讨论物理 KASLR 绕过与缓存刷新

4. **PageJack**（Phrack/BlackHat，2024）  
   https://phrack.org/issues/71/13#article  
   https://i.blackhat.com/BH-US-24/Presentations/US24-Qian-PageJack-A-Powerful-Exploit-Technique-With-Page-Level-UAF-Thursday.pdf

### GPU 漏洞案例

5. **GPUAF**（aarch64，2024）  
   https://powerofcommunity.net/poc2024/Pan%20Zhenpeng%20&%20Jheng%20Bing%20Jhong,%20GPUAF%20-%20Two%20ways%20of%20rooting%20All%20Qualcomm%20based%20Android%20phones.pdf

6. **The Way to Android Root**（aarch64，2024）  
   https://i.blackhat.com/BH-US-24/Presentations/REVISED02-US24-Gong-The-Way-to-Android-Root-Wednesday.pdf

7. **CVE-2022-22265**（aarch64，2024）  
   https://soez.github.io/posts/CVE-2022-22265-Samsung-npu-driver/

8. **Mali-cious Intent**（aarch64，2025）  
   https://starlabs.sg/blog/2025/12-mali-cious-intent-exploiting-gpu-vulnerabilities-cve-2022-22706/#exploitation-primitive

### 背景知识

- **Linux 页表文档**  
  https://docs.kernel.org/mm/page_tables.html

- **linternal 系列**（作者）  
  https://sam4k.com/linternals/

- **A Quick Dive Into The Linux Kernel Page Allocator**（2025）  
  https://syst3mfailure.io/linux-page-allocator/

- **Reverse Engineering Hardware Page Table Caches Using Side-Channel Attacks on the MMU**  
  关于 TLB 与页表缓存刷新的学术论文

---

## 总结

页表利用展示了"在虚拟地址层缓解之外"的一条通路：当我们直接操纵物理地址时，许多常见保护（虚拟 KASLR、只读页面、堆随机化等）会失去效力或被绕过。

**Dirty Pagetable 的核心价值：**
- 提供了从 SLAB 级漏洞到页级控制的通用转换方法
- 纯数据利用，天然绕过 CFI/SMAP/PAN
- 适用于最新内核，弥补 KSMA 被缓解后的空白
