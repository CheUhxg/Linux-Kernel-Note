# Dirty Page Table

* [参考](https://yanglingxi1993.github.io/dirty_pagetable/dirty_pagetable.html)

## 简介

Dirty Pagetable 是一种全新的内核漏洞利用方法。该方法的核心思想是利用基于堆的漏洞来操纵用户页表，从而为我们提供一个强大的原语（primitive）：读写任意物理地址。我们将此方法命名为 Dirty Pagetable。

与现有的内核利用方法相比，Dirty Pagetable 具有许多显著的优势。
**首先，它是一种纯数据（data-only）漏洞利用技术**，因此可以天然地绕过许多强大的缓解技术，如 CFI、KASLR、SMAP/PAN 等。这一特性也有助于我们开发通用利用（universal exploit）。
**其次，它是一种强大的利用方法，并且仍然适用于最新的 Linux 内核。**众所周知，内核空间镜像攻击（KSMA）是一种强大的内核利用方法，已被广泛应用多年。然而，在较新的 Linux 内核上，该方法已被缓解。但 Dirty Pagetable 依然有效，并且能轻而易举地达到同样的效果。
**第三，它可以显著提高许多基于堆的漏洞的利用效果。**我们注意到，许多内存损坏漏洞的利用方式倾向于攻击只读二进制文件或库的页缓存（page cache）。在安卓（Android）系统上，这种方法需要付出更多努力才能实现完整的权限提升。但是，Dirty Pagetable 可以利用这些基于堆的漏洞直接攻击内核，从而让我们能更方便地完成权限提升。

我们在最新的谷歌 Pixel 7——谷歌迄今为止最安全、最注重隐私的手机上——成功实现了权限提升。我们利用最近发现的一个 0-day 漏洞（CVE-2023-21400）完成了此次利用，并成功绕过了谷歌 Pixel 7 上部署的所有缓解技术。此外，我们还利用 Dirty Pagetable 为两种常见的漏洞类型——文件 UAF（Use-After-Free）和 pid UAF——开发了新的利用方法。与已知的利用方法相比，Dirty Pagetable 已将这些漏洞的利用技术推向了一个新的高度。

## 概述

Dirty Pagetable 可被用来利用基于堆的漏洞，例如堆 use-after-free（UAF）、double-free 以及out-of-bounds（OOB）漏洞等。为了更直观地说明，我们以一个常见的 UAF 漏洞为例，分步骤简要描述如何借助 Dirty Pagetable 利用这类基于堆的漏洞：

### 步骤 1：触发 UAF，使“受害 slab”被回收回页分配器

如前所述，UAF 漏洞会导致某个堆对象被提前释放，但之后仍有可能被再次使用。我们把这个堆对象称为“受害对象（victim object）”。由于 Linux 内核使用 slab 分配器来管理各类堆对象，为了叙述方便，我们称该受害对象所在的 slab 为“受害 slab（victim slab）”。

通过触发 UAF，我们首先让受害对象被释放。接着，如果我们继续释放受害 slab 中的其它所有对象，该 slab 便成为空 slab，进而可以被回收回页分配器（许多研究者已讨论过如何快速、稳定地让空 slab 被页分配器回收，这里不再赘述）。

至此，受害 slab 已被回收到页分配器。

### 步骤 2：用用户页表占用受害 slab

由于用户页表直接从页分配器分配，我们可以通过一次性分配大量用户页表来占用受害 slab。请注意，这里我们使用的是最后一级页表（last-level page tables）。

一旦成功用用户页表占用了受害 slab，就可能出现如下场景：

![](./images/pic1_occupy_with_pagetable.svg)

如你所见，受害对象此刻位于一张用户页表之中。

### 步骤 3：构造可任意改写页表项（PTE）的利用原语  

完成步骤 2 后显而易见：只要我们能用受害对象构造出一种写（write）原语，就能按需修改页表项（PTE）。

在 Dirty Pagetable 中，如何利用受害对象构造出合适的原语以修改 PTE 是一大挑战。

> TODO: 添加三个例子。

至此，可假定我们已经拿到了一个能任意改写用户页表内 PTE 的写原语。

### 步骤 4：通过修改 PTE 打补丁到内核  

完成步骤 3 后，我们便能够控制某一 PTE。只需将该 PTE 的物理地址指向内核代码段或数据段的物理地址，就可以随意给内核“打补丁”！

为了完成权限提升，我们选择给若干系统调用打补丁，如 setresuid()、setresgid() 等，使得普通进程也能直接调用它们。如果系统启用了 SELinux，还可能需要再修改 SELinux 相关变量以将其关闭。

### 步骤 5：获取 root 权限  

由于 setresuid() 和 setresgid() 已被补丁修改，我们只需执行以下代码即可直接获得 root 权限：

```c
if (setresuid(0, 0, 0) < 0) {
    perror("setresuid");
} else {
    if (setresgid(0, 0, 0) < 0) {
        perror("setresgid");
    } else {
        printf("[+] Spawn a root shell\n");
        system("/system/bin/sh");
    }
}
```

以上五个步骤展示了 Dirty Pagetable 的最简流程。

## 挑战

在利用相关漏洞的过程中，我们碰到了一些难以直接解决的问题，它们一度阻碍了 Dirty Pagetable 的正常使用。我们花了大量时间才将这些障碍逐一排除。下面列出这些难题及我们的解决方案。

### 如何刷新 TLB 与页表缓存  

为了加速 MMU 的页表查找，ARM64 引入了多级缓存，例如转译后备缓冲器（TLB）以及专用的页表缓存。要在 Dirty Pagetable 中成功利用漏洞，必须在访问用户页表前可靠地刷新这些缓存；否则，内核补丁可能无法生效。  

幸运的是，Stephan van Schaik、Kaveh Razavi、Ben Gras、Herbert Bos 与 Cristiano Giuffrida 在论文《Reverse Engineering Hardware Page Table Caches Using Side-Channel Attacks on the MMU》 中提出了一种可靠的方法来刷新这些缓存。我们沿用了该方法，能够稳定地刷新 TLB 及其余页表缓存。

### 如何在提权过程中避免对页表的意外操作  

利用 Dirty Pagetable 时可能出现两类意外行为：

第一类意外：误用非末级页表占用受害 slab。  
例如，在 Android 上我们可能用 2 级页表占用了受害 slab，而非所需的 3 级（末级）页表。只有用末级页表成功占位，Dirty Pagetable 才能按预期工作；若占位错误，内核会出现诡异错误。根本原因是我们忽略了：在大量分配末级页表的过程中，也可能顺带分配非末级页表。  
规避方法：在用末级页表做堆喷（heap-spray）之前，先触发一次非末级页表的分配，把它们“预占”掉，确保后续只会分配末级页表到受害 slab。

第二类意外：内核可能将我们正要修改的 PTE 所指向的页面换出（swap out）。  
此时该 PTE 将变为非法，若再访问其对应的虚拟地址，内核就会 panic。  
规避方法：  
1. 使用 mlock() 把该虚拟地址对应的页面锁在内存中；  
2. 或避免系统内存压力过大，防止该页被换出到交换分区。

## 缓解措施  

可在多个维度缓解 Dirty Pagetable 的威胁：
1. 内核物理地址随机化（KASLR）。  
虽然我们无法直接获知内核的精确物理地址，但仍可转而篡改其他无需绕过地址随机化的内核堆数据来完成提权。因此，KASLR 只能提供有限缓解。

2. 将用户页表设为只读。  
这样即使漏洞存在，也无法直接修改用户页表，能显著削弱 Dirty Pagetable。但该做法会增加内核在修改页表时的额外开销。

3. 借助 Hypervisor 或 TrustZone 技术，把内核代码段及其他关键内存区域设为只读。  
该方案能彻底阻止 Dirty Pagetable 篡改内核代码及关键数据，是目前最有效的防御手段之一。