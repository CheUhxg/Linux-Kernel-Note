# 地址类型对比

| 类型         | 含义                                                                                     | 例子／用途                                                                |
| ---------- | -------------------------------------------------------------------------------------- | -------------------------------------------------------------------- |
| 虚拟地址   | CPU 在执行指令时看到的地址；分为用户态空间和内核态空间。                                                         | 用户进程的栈、堆，中断向量表，`task_struct` 等                                       |
| 物理地址   | 真实的内存总线地址；DRAM 芯片上的行、列、Bank 等硬件地址。                                                     | DRAM 硬件读写时真正使用的地址                                                    |
| 线性映射地址 | Linux 内核将整个物理内存以一段“连续”的虚拟区间直接映射起来——也叫 “直接映射区” 或者 `physmap`。这部分虚拟地址到物理地址的映射是 1:1 的偏移关系。 | 默认在 64 位 x86 上通常从 `0xffff880000000000`（`PAGE_OFFSET`） 开始，大小等于物理内存大小。 |

* 虚拟→物理
  * 正常用户空间和内核空间的虚拟地址，都要走页表（page table）才能翻译到对应的物理页框（page frame）。
  * 线性映射区内，虚拟地址 $\mathtt{VA}$ 与物理地址 $\mathtt{PA}$ 的关系非常简单：

    $$
      \mathtt{VA} = \mathtt{PA} + \text{OFFSET}
    $$

    其中 OFFSET 就是内核为 physmap 预留的起始偏移。
* 为什么要转换？
  * `init_task`、`_text_start` 等符号在内核 ELF 映像里的地址是 内核的链接虚拟地址（Link VA），并不直接等同于运行时的 physmap 中的虚拟地址。
  * 若内核启用了物理地址随机化，物理的加载基址（PA base）被随机偏移了，那么对应的线性映射区起始也会相应改变。我们要访问 `init_task`，首先需要把其链接虚拟地址转换成物理地址，再加上 physmap 偏移，才能得到真正的运行时虚拟地址。

线性映射区（也常称为 **physmap** 或 **direct‐map** 区域）本质上也是内核的**虚拟地址空间**的一部分，只不过它跟物理内存的一段区间做了“1:1 偏移”映射。
* **虚拟地址 vs. 线性映射地址**
  * “虚拟地址”是 CPU 在运行时看到并通过页表转换的地址，分为用户态空间和内核态空间两大部分。
  * 线性映射区就是内核态空间里专门用来直接映射所有物理内存的那块连续虚拟区间。凡是落在这段区间里的地址，都可以通过一个简单的加减偏移直接对应到物理地址，无需多级页表查找。
* **映射关系**
  $$
    \text{virt\_addr（线性映射）} = \text{phys\_addr} + \text{PAGE\_OFFSET}
  $$
  其中 `PAGE_OFFSET`（在 x86\_64 Linux 上通常是 `0xffff880000000000` 或类似值）标志着这段映射区在虚拟空间的起始位置。

# struct page

## `struct page` 的作用与定位

* **物理页的抽象**：内核把物理内存拆成若干个固定大小（通常 4 KiB）的“页”（page）。`struct page` 就是用来描述每个物理页的元数据结构。通过这个结构，内核可以管理页的分配、回收、缓存、换出、映射关系等等。
* **每页一个实例**：在系统启动时，为物理内存中每个页分配一个 `struct page` 对象，这些对象通常被连续地放在一个专门的 `page_alloc` 池里。物理地址为 `PA = N * PAGE_SIZE` 的第 N 页，它的 `struct page` 定位为 `mem_map[N]`。
* **线性映射**：这些 `struct page` 本身也被映射到内核虚拟地址空间（physmap）的一段区域里，方便内核代码直接通过指针访问。

## `struct page` 在内存管理中的角色

1. **伙伴分配器（Page Allocator）**：分配/回收物理页时，先在空闲链表中摘下 `struct page`，再把它的物理页框提供给请求者。
2. **页缓存（Page Cache）**：文件 I/O 时，把磁盘块映射成 `struct page` 并维护在 LRU 链表中，可通过 `mapping->page_tree`、`page_cache_alloc()` 等 API 访问。
3. **交换（Swap）**：匿名页、私有页在内存压力时会被换出（swap），`struct page` 中的标志位和引用计数决定何时可写回并回收。
4. **内核对象缓存（SLAB/SLUB）**：每个页也可以被用来划分给 SLAB 分配器；`slab_cache` 指向所属 kmem\_cache，`private` 存对象统计。
5. **虚拟内存映射**：在 mm\_struct 的 VMA/Page Table 中通过 `pte→_PAGE_PAGE` 等宏把 `struct page` 与虚拟页关联，用于地址转换和缺页处理。

# 物理地址随机化

## 概念
物理地址随机化（Physical KASLR，Kernel Address Space Layout Randomization）是指在引导时，将内核镜像（text、data、.bss 等段）在物理内存中的加载位置打乱，使其不总是固定加载到同一个物理帧上。这样，即使攻击者知道内核在虚拟地址空间中的线性映射偏移，也无法预先计算出对应的物理地址，从而增加了针对物理内存布局的攻击难度。

## 作用
  * 防止基于物理内存布局的侧信道或硬件漏洞利用（比如 DMA 攻击、ROWHAMMER 等）。
  * 结合虚拟地址随机化（Virtual KASLR）一起，极大增加了攻击者定位关键内核结构的难度。

## 举例流程

1. 链接时
   * `init_task` 在链接时可能被定位到虚拟地址 `0xffffffff81000000`（Link VA）。
2. 物理加载
   * 如果不开启物理随机化，内核镜像被加载到物理地址 `0x100000`，那么运行时它在 physmap 中的虚拟地址就是
     $$
       0xffff880000000000 + 0x00100000 \;=\; 0xffff880001000000.
     $$
   * 若开启了物理随机化，假设随机偏移 +`0x08000000`，则它被加载到物理 `0x08100000`，运行时的虚拟物理映射地址则变为
     $$
       0xffff880000000000 + 0x08100000 \;=\; 0xffff880081000000.
     $$
3. 访问转换
   * 我们先用读原语从 kernel image 段读取 Link VA 对应的物理偏移（一般在引导信息或 EFI handover block 中可以拿到 randomized PA base）。
   * 再加上 physmap 的起始偏移，就能算出真正的 runtime VA，从而对 `init_task` 执行遍历。

