# 后利用技术

当我们已经有某种任意/部分的内核读/写原语了，接下来就是利用这个原语了。

## 符号表泄漏

* 参考[badspin](https://github.com/0xkol/badspin)

> 适用设备：Pixel 系列（GKI 内核，未开放 `/proc/kallsyms` 或符号被裁）
> 前置能力：已拥有内核任意读
> 最终产出：
> 1. 完整的内核头部 32 MB 内存镜像（dump）；
> 2. 现场重建 kallsyms，精确获得 kernel base 及任意符号地址；
> 3. 为后续 PGD 定位、KSMA（kernel space mirroring attack）等高级利用铺路。

### 地址与长度选择

aarch64 的「线性映射」固定从 `0xffffff8000000000UL` 开始，经验长度 0x02000000（32 MB）可同时覆盖：  
  | 固件类型 | 典型大小 | 备注 |  
  |---|---|---|  
  | GKI 内核 | ≈ 20 MB | Google 官方通用镜像 |  
  | Samsung 定制 | ≈ 28 MB | 含大量驱动 |  

再往上读容易触发物理页缺失（Page Fault）或耗时过长，得不偿失。  

> 目标：在没有任何符号文件的前提下，复现内核自举时构建的 `kallsyms` 全貌。  
> 原理：Linux 的 `kallsyms` 在编译期被连续地放进 `.rodata`，各子结构的偏移彼此依赖，形成一条可推导的因果链。

### 整体布局回顾  
```
……[rodata]……
kallsyms_token_table
kallsyms_token_index
kallsyms_markers
kallsyms_num_syms
kallsyms_names
kallsyms_offsets
kallsyms_relative_base
……
```
所有地址均为 **物理装载地址**（运行时随机化后仍然线性映射），因此 dump 里能看到它们的「真实」形态。

| 步骤 | 要确定的符号 | 锚点 & 校验逻辑 | 设计理由 |
|---|---|---|---|
| ① | `kallsyms_token_table` | 搜索常量字节序列 `0 1 2 3 4 5 6 7 8 9` 的 ASCII 形态（每个数字后跟 `\0`），**再向前**必须出现 ≥3 个连续 `\0` 且 8 字节对齐 | 数字 token 在所有内核版本恒定；对齐可排除误报 |
| ② | `kallsyms_token_index` | 从 token_table **末尾**再数 **256 个 `\0`**，随后 8 字节对齐 | token 共 256 个，每个以 `\0` 结尾；索引表紧跟其后且必须对齐 |
| ③ | `kallsyms_markers` | 从 token_table **向前**找 **第一个 0 值 u32**；再向前到首个非 0 | markers 每 256 个符号存一个 u32 偏移，首条目恒 0；差值×256≈符号总数 |
| ④ | `kallsyms_num_syms` | 在 markers **前**继续倒搜 4 byte，若 **近似值-精确值 ≤ 0x100** 且 **前一个 8 byte 的高位为 `0xffffffc`** | 精确符号数必须与近似值误差 <256；前一个 8-byte 必为 `kallsyms_relative_base` |
| ⑤ | `kallsyms_names` | 紧跟在 num_syms 之后，8 字节对齐 | names 是压缩串流，首字节必为长度（≠0）；遍历到第 num_syms 条必须恰好结束 |
| ⑥ | `kallsyms_offsets` | **公式：offsets = token_index + 512**，再计算<br>`relative_base = offsets + num_syms * 4` | token_index 固定 512 字节，后接 4-byte 偏移数组；末尾 8-byte 即运行时基址 |

完成 ①→⑥ 后，我们已拥有：
- 运行时 `relative_base`（== 内核装载基址 + 常量）；  
- 完整的 offsets 数组（所有符号的 **相对** 偏移）；  
- names 串流（可被 token_table / token_index 解压成符号字符串）。

### 计算 kernel base

- 在解压后的符号表中查找 `_text`（内核代码段起始）；  
- 该符号的 **运行时地址** = `relative_base + offsets[_text_index]`；  
- 运行时地址减去 `_text` 在 ELF 内的偏移 == **真正的 kernel base**。

## 内核 PGD 定位与页表漫游

* [Locating the kernel PGD on Android/aarch64](https://duasynt.com/blog/android-pgd-page-tables)

> 原文：twitter 速记补充，现整理成中文备忘，供 Pixel 系列（GKI，无 /proc/kallsyms）场景下参考。  
> 前置：已具备任意/部分内核读写能力。  
> 目标：找到 `swapper_pg_dir`，进而手动走查页表，验证 PTE 属性或做 KSMA 等后渗透。

某些厂商的内核加固（PXN、PAN、SELinux 等）依赖严格的页表权限。如果能直接拿到并修改页表（KSMA 的思想），就可以绕过这些缓解。KSMA 在 Android/aarch64 上被重新包装，但本质仍是「修改页表」这一古老技法的回炉重造。

### 整体思路  

1. 先确定 `_text` 的起始地址；  
2. 从 `_text` 所在页读出「kernel text offset」和「kernel image size」；  
3. 用这两个值算出 `swapper_pg_dir` 的虚拟地址；  
4. 若 `_text` 未知，则通过 kernel magic 在 physmap 中逆向搜索；  
5. 拿到 PGD 后即可手动 walk page tables，验证或篡改任何虚拟地址的 PTE。

### 已知 `_text` 时一步到位  

在启用了 KASLR 的设备上，先读出第一条符号：

```
sunfish:/ # grep _text /proc/kallsyms | head -1
ffffff93e7880000 T _text
```

`_text` 所在页的前几个八字节就是 kernel header。第二个与第三个八字节分别为：

- `kernel text offset`（从物理地址 0 到 `_text` 的偏移）  
- `kernel image size`（整个内核镜像大小）

示例：

```
(gdb) x/4xg 0xffffff93e7880000
0xffffff93e7880000: 0x0000000014608000  0x0000000000080000
0xffffff93e7880010: 0x0000000002426000  0x000000000000000a
```

此时 PGD 的虚拟地址可快速算得：

```
PGD_VA = _text + image_size - 2 * PAGE_SIZE
       = 0xffffff93e7880000 + 0x2426000 - 0x2000
       = 0xffffff93e9ca4000
```

与 GDB 打印的符号地址完全一致：

```
(gdb) p/x &swapper_pg_dir
$1 = 0xffffff93e9ca4000
```

### `_text` 未知时的回退方案  

若没有 `/proc/kallsyms`，仍可在 physmap 中做盲搜：

1. 假设 physmap 未随机化：  
```
PGD_PA = 0x0000000002086000 + 0x0000000000080000 - 0x2000
PGD_VIRT = 0xffffffc000000000 + PGD_PA
```

2. 若 physmap 被随机化：在整个 physmap 区域里按页扫 kernel magic（同样是上述 16 字节模式），找到 slide 后重复上述计算即可。

### 手动页表漫游示例

说明：39-bit VA、4 KB 页、三级页表（PGD→PUD→PMD→PTE）。  
示例地址：`0xffffff8008080000`（无 KASLR 的 `_text`）。

1. 解析虚拟地址

| 字段       | 位宽 | 计算式                         | 结果 |
|------------|------|--------------------------------|------|
| PGD index  | 9    | `(VA & 0x7fc0000000) >> 30`    | 0x00 |
| PUD index  | 9    | `(VA & 0x3fe00000) >> 21`      | 0x40 |
| PMD index  | 9    | `(VA & 0x1ff000) >> 12`        | 0x80 |
| page offset| 12   | `VA & 0xFFF`                   | 0x000 |

> 注：39-bit VA 只用到低 39 位；高 25 位全 1 表示内核空间。

2. 获得 PGD 入口物理地址，从上一节已知：  
```
swapper_pg_dir_phys = 0x1fa7fe000
```

3. 把 PGD 物理地址映射到 physmap  
```
physmap_base  = 0xffffffc000000000  
phys_offset   = 0x80000000              # 物理 RAM 起始  
PGD_virt      = physmap_base + swapper_pg_dir_phys - phys_offset  
             = 0xffffffc17a7fe000
```

4. 取 PMD 描述符  
```
pmd_desc_addr = PGD_virt + PUD_index * 8  
              = 0xffffffc17a7fe000 + 0x40 * 8  
pmd_desc      = *(u64 *)pmd_desc_addr  
              = 0x00000001fa7fd003
```
- bits [47:12] = 0x1fa7fd000 → PMD 表物理基址  
- bits [1:0]   = 0b11         → VALID | TABLE

5. 取 PTE 描述符  
```
pte_tbl_phys = pmd_desc & ~0xFFF          # 去掉属性位  
pte_virt     = physmap_base + pte_tbl_phys - phys_offset  
pte_desc_addr= pte_virt + PMD_index * 8  
             = 0xffffffc17a7fd000 + 0x80 * 8  
             = 0xffffffc17a7fd400
pte_desc     = *(u64 *)pte_desc_addr  
             = 0x00d0000080080793
```

6. 解读 PTE 字段  
```
bit[47:12]  PFN          = 0x8008000  
bit[11:10]  AP[2:1]      = 10b → EL1 读写，EL0 禁止  
bit[7:6]    AP[1:0]      = 00b  
bit[5]      AF           = 1 (Access Flag)  
bit[4:2]    AttrIndx     = 100 (Device-nGnRnE)  
bit[1:0]    VALID        = 1
```

7. 权限篡改  

把 `AP[2:1]` 从 `10` 改为 `01`，即：

``` diff
- 0x00d0000080080793  
+ 0x00d0000080080693
```

写入后，该 4 KB 页立即对 EL0 开放读写，实现最简单的权限绕过。

8. 速查表

| 步骤 | 目的地址 | 计算 | 结果 |
|---|---|---|---|
| PGD | 0xffffffc17a7fe000 | physmap + swapper_pg_dir_phys - phys_offset | 页表顶层 |
| PMD | 0xffffffc17a7fe200 | PGD_virt + 0x40\*8 | PMD 描述符 |
| PTE | 0xffffffc17a7fd400 | physmap + PMD_phys - phys_offset + 0x80\*8 | 最终页描述符 |

至此完成一次完整的手工页表漫游。

### 一键脚本  

上方 gdb 会话中的 `page_table.py` 已开源（见原帖 repo）。  
用法示例：

```
(gdb) source ~/repos/gdb_scripts/page_table.py
(gdb) get_pte &selinux_enforcing
```

脚本会：
- 自动计算 kernel image size  
- 定位 kernel PGD  
- 完成四级页表 walk  
- 打印所有 PTE 字段：AttrIndx、AP、PXN、UXN 等
